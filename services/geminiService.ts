
import { GoogleGenAI, Type } from "@google/genai";
import { AnalysisResult } from "../types";

const fileToBase64 = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => {
            const result = reader.result as string;
            resolve(result.split(',')[1]);
        };
        reader.onerror = (error) => reject(error);
    });
};

const PROMPT = `You are AutoNet, an advanced AI Network Automation Engine. Your task is to analyze the provided network topology (text description or visual input) and generate a comprehensive automation package.

**STRICT OUTPUT FORMAT:**
You must output ONLY a valid, parseable JSON object. Do not include markdown formatting (like \`\`\`json), preamble, or postscript.

**JSON SCHEMA STRUCTURE:**
Your response must strictly follow this structure:
{
  "topology_summary": "String describing the detected architecture (e.g., 'Hub and Spoke with 3 branches')",
  "devices": [
    {
      "hostname": "String (e.g., 'R1')",
      "type": "String (e.g., 'Router', 'Switch')",
      "config": "String (The full Cisco IOS config with \\n for newlines)",
      "validation_audit": [
        {
          "rule_id": "String (e.g., 'R1')",
          "severity": "String ('error' | 'warning' | 'info')",
          "message": "String describing the finding"
        }
      ]
    }
  ],
  "ansible_playbook": "String (The full YAML playbook)",
  "assessment": {
    "strengths": ["String"],
    "weaknesses": ["String"],
    "scalability_score": "Integer (1-10)"
  },
  "recommendations": ["String", "String", "String"],
  "visualization_svg": "String (A valid, self-contained <svg> string)"
}

**TASK REQUIREMENTS:**

1. **Device Configurations (Cisco IOS):**
   - Include the header: "! === GENERATED BY AUTONET === !".
   - Ensure specific interface IP assignments based on the topology.
   - Configure OSPF/BGP if routing is implied.

2. **Configuration Validation Audit:**
   Audit every device against these rules:
   - R1: Interfaces must have descriptions.
   - R2: SSH enabled (no Telnet). Domain name required for crypto key.
   - R3: Passwords encrypted (service password-encryption).
   - R4: Enable secret used.
   - R5: Unused interfaces shutdown.
   - R6: Valid Syntax.

3. **Ansible Playbook:**
   - Generate a single \`site.yml\` playbook.
   - Use standard \`cisco.ios\` collection modules.
   - Ensure idempotency where possible.

4. **Visualization (SVG):**
   - Create a clean, modern SVG (dark mode compatible).
   - Use <rect> for devices and <line> for connections.
   - Ensure text labels are legible and contrasting (fill="#ffffff").
   - Dimensions: Viewbox "0 0 800 600".

**CRITICAL PARSING RULES:**
- Escape all double quotes inside strings as \\".
- Escape all newlines inside strings as \\n.
- Do not output trailing commas in arrays/objects.
`;
const responseSchema = {
  type: Type.OBJECT,
  properties: {
    deviceConfigs: {
      type: Type.ARRAY,
      description: "An array of device configuration objects.",
      items: {
        type: Type.OBJECT,
        properties: {
          deviceName: {
            type: Type.STRING,
            description: "The hostname or name of the network device."
          },
          config: {
            type: Type.STRING,
            description: "The full Cisco IOS-style configuration for this device."
          },
          validationFindings: {
            type: Type.ARRAY,
            description: "Validation results based on predefined best-practice rules.",
            items: {
              type: Type.OBJECT,
              properties: {
                severity: {
                  type: Type.STRING,
                  enum: ["error", "warning", "info"],
                  description: "Severity level of the finding."
                },
                message: {
                  type: Type.STRING,
                  description: "Detailed description of the rule violation or best practice suggestion."
                }
              },
              required: ["severity", "message"]
            }
          }
        },
        required: ["deviceName", "config", "validationFindings"]
      }
    },
    ansiblePlaybook: {
      type: Type.STRING,
      description: "A complete, annotated Ansible playbook in YAML format."
    },
    assessment: {
      type: Type.STRING,
      description: "A detailed network assessment."
    },
    recommendations: {
      type: Type.ARRAY,
      description: "A list of concrete improvement recommendations.",
      items: {
        type: Type.STRING
      }
    },
    topologySketch: {
        type: Type.STRING,
        description: "An SVG string if input was text, otherwise an empty string."
    }
  },
  required: ["deviceConfigs", "ansiblePlaybook", "assessment", "recommendations", "topologySketch"]
};

export const analyzeTopology = async (file: File | null, text: string | null): Promise<AnalysisResult> => {
    const apiKey = process.env.API_KEY;
    if (!apiKey) {
        throw new Error("API key is not configured.");
    }
    
    const ai = new GoogleGenAI({ apiKey });

    const parts: ({ text: string } | { inlineData: { data: string; mimeType: string } })[] = [{ text: PROMPT }];

    if (file) {
        const base64Data = await fileToBase64(file);
        parts.push({
            inlineData: {
                data: base64Data,
                mimeType: file.type,
            },
        });
    } else if (text) {
        parts.push({ text: `User text: \n\n${text}` });
    } else {
        throw new Error("No input provided.");
    }

    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: { parts },
            config: {
                responseMimeType: "application/json",
                responseSchema: responseSchema,
                temperature: 0.1,
            },
        });
        
        let jsonString = response.text.trim();
        const match = /```json\s*([\s\S]*?)\s*```/.exec(jsonString);
        if (match) {
            jsonString = match[1];
        }

        const result: AnalysisResult = JSON.parse(jsonString);
        return result;

    } catch (error) {
        console.error("Error calling Gemini API:", error);
        if (error instanceof SyntaxError) {
             throw new Error("Failed to parse AI response. Please try a simpler topology.");
        }
        throw new Error("Failed to analyze the topology. Please try again.");
    }
};
